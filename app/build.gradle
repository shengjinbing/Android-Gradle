apply plugin: 'com.android.application'

android {
    compileSdkVersion 27
    defaultConfig {
        applicationId "com.example.administrator.myapplication"
        minSdkVersion 15
        targetSdkVersion 27
        versionCode 1
        versionName "1.0"
        testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
    }
    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
        }
    }
}

dependencies {
    implementation fileTree(dir: 'libs', include: ['*.jar'])
    implementation 'com.android.support:appcompat-v7:27.1.1'
    implementation 'com.android.support.constraint:constraint-layout:1.1.2'
    testImplementation 'junit:junit:4.12'
    androidTestImplementation 'com.android.support.test:runner:1.0.2'
    androidTestImplementation 'com.android.support.test.espresso:espresso-core:3.0.2'
}

task hello {
    doLast {
        logger.quiet("dsadasdas")
    }
}

/****************字符串相关*******************/
task printStringClass << {
    def str1 = '单引号单引号'
    def str2 = 'shanu引号单引号'

    println(str1.getClass().name)
    println(str2.getClass().name)


}

task printStringVal << {
    def str = 'zhangsan'

    //单引号没有运算能力
    println('haha:${str}')
    println("haha:${str}")
}

/****************集合相关*******************/
task printList << {
    def numList = [1, 2, 3, 4, 5, 6]
    //printIn(numList.getClass().name.toString())
    print(numList.getClass().name.toString())
    println(numList[1])//访问第一个元素
    println(numList[-1])//访问最后一个元素
    println(numList[-2])//访问倒数第二个元素
    println(numList[1..3])//访问第二到第四个元素

    //呆板写法
    numList.each({ print it })
    //格式化一下
    numList.each({
        print it
    })
    //groovy规定最后一个参数是闭包可以放到方法外面去
    numList.each(){
        print it
    }
    //然后方法可以省略，就变成我们经常写的样式
    numList.each {
        print it//必须是it这是闭包的知识
    }

}

task printMap << {
    def map1 = ['width': 1024, 'height': 768]
    def name = map1.getClass().name;
    println(name)

    println(map1['width'])
    println(map1['height'])

    map1.each {
        print "key:${it.key},Vaule:${it.value}"
    }

}
/****************方法相关*******************/
//括号可以省略
task invokeMethod << {
    method(1, 3)
    method 1, 2
}

def method(int a, int b) {
    print a + b
}

//return 是可以不写的 我们定义有返回值的方法时，return语句不是必须的，会把最后一句作为返回值
task invokeMethodReturn << {
    def c = method1 1, 3
    def d = method1 3, 1
    print c
    print d

}

def method1(int a, int b) {
    if (a > b) {
        a
    } else {
        b;
    }
}

//代码块可以传递，一段被花括号包围的代码，其实就闭包


